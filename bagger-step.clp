;;; Jordan Stein
;;; AI Program 3
;;; 4/15/2017

;;;(deffacts initial-facts
;;;(step check-order))



;;; An item represents something to be bagged.
(deftemplate item
(slot name
(type SYMBOL))
(slot container-type
(type SYMBOL))
(slot size
(allowed-values small medium large))
(slot frozen
(allowed-values no yes)
(default no)))



;;; New bag names are generated by keeping a counter, which is initializes to
;;; zero, and when we need a new bag we increment the counter and create a
;;; symbol by appending to the "bag". This is a purely procedural approach.
(defglobal ?*prev-bag-number* = 0)
(deffunction new-bag-name ()
(bind ?*prev-bag-number* (+ ?*prev-bag-number* 1))
(sym-cat bag ?*prev-bag-number*))



;;; The current bag has a name as well as the number and size of its contents.
;;; For bagger, bags only have items of a particular size. Note that current-bag
;;; self initializes - name defaults to the next bag name, item-count defaults
;;; to zero, and item-size initializes to nil, which won't match any known size.
(deftemplate current-bag
(slot name
(type SYMBOL)
(default-dynamic (new-bag-name)))
(slot item-count
(type INTEGER)
(default 0))
(slot item-size
(type SYMBOL)))



;;; Bagged facts represent items that have been bagged.
(deftemplate bagged
(slot item-name
(type SYMBOL))
(slot bag-name
(type SYMBOL)))



;;; The initial facts for Bagger. Note that the pepsi is commented out. This
;;; allows you to test rule B1.
(deffacts initial
(current-bag)
(item (name bread) (container-type plastic-bag) (size medium))
(item (name glop) (container-type jar) (size small))
(item (name granola) (container-type cardboard-box) (size large))
(item (name ice-cream) (container-type cardboard-carton) (size medium) (frozen yes))
(item (name potato-chips) (container-type plastic-bag) (size medium))
;(item (name pepsi) (container-type bottle) (size large))
)



(defrule B0
=>
(printout t "Bagger Production System" crlf)
(set-strategy complexity)
(assert (step check-order)))



(defrule B1
(step check-order)
(item (name potato-chips))
(not (item (name pepsi)))
=>
(printout t "Do you want a bottle of Pepsi? ")
(if (= (str-compare (upcase (readline t)) "YES") 0)
then (assert (item (name pepsi) (container-type bottle) (size large)))))



(defrule B2
?step-fact <- (step check-order)
=>
(retract ?step-fact)
(assert (step bag-large-items)))



(defrule B3
(step bag-large-items)
?item-fact <- (item (name ?item-name) (container-type bottle) (size large))
?current-bag-fact <- (current-bag (name ?bag-name) (item-count ?item-count&:
(< ?item-count 6)))
=>
(retract ?item-fact)
(assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
(modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size large)))






;;; if step is bag-large-items
;;; 		a large item is to be bagged
;;;			the current bag contains < 6 large items
;;; delete 	the large item to be bagged
;;; add 	the large item is in the current bag
(defrule B4
(step bag-large-items)
?item-fact <- (item (name ?item-name) (size large))
?current-bag-fact <- (current-bag (name ?bag-name) (item-count ?item-count&:
(< ?item-count 6)))
=>
(retract ?item-fact)
(assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
(modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size large)))






(defrule B5
(step bag-large-items)
(item (name ?item-name) (size large))
?current-bag-fact <- (current-bag)
=>
(retract ?current-bag-fact)
(assert (current-bag)))



(defrule B6
?step-fact <- (step bag-large-items)
=>
(retract ?step-fact)
(assert (step bag-medium-items)))





;;; if step is bag-medium-items
;;;			a medium item is frozen, but not in a freezer bag-large-items
;;; delete 	the medium item is not in a freezer bag
;;; add 	the medium item is in a freezer bag
(defrule B7
(step bag-medium-items)
?item-fact <- (item (name ?item-name) (frozen yes) (size medium))
?current-bag-fact <- (current-bag (name ?bag-name) (item-count ?item-count))
=>
(retract ?item-fact)
(assert (bagged (item-name ?item-name) (bag-name freezer-bag)))
(modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size large)))





(defrule B8
(step bag-medium-items)
?item-fact <- (item (name ?item-name) (size medium))
?current-bag-fact <- (current-bag (name ?bag-name) (item-count ?item-count)
(item-size ?item-size))
(test (or (= ?item-count 0) (and (eq ?item-size medium) (< ?item-count 12))))
=>
(retract ?item-fact)
(assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
(modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size medium)))






;;; if 	step is bag-medium-items
;;;			a medium item is to be bagged
;;;			an empty bag is available
;;; delete 	the current bag is the current bag
;;;	add		the empty bag is the current bag
(defrule B9
(step bag-medium-items)
(item (name ?item-name) (size medium))
?current-bag-fact <- (current-bag)
=>
(retract ?current-bag-fact)
(assert (current-bag)))






(defrule B10
?step-fact <- (step bag-medium-items)
=>
(retract ?step-fact)
(assert (step bag-small-items)))





;;; STILL NEEDS WORK TO CHECK IF CURRENT BAG CONTAINS NO LARGE/MEDIUM ITEMS
;;; if 	step is bag-small-items
;;; 		a small item is to be bagged
;;;			the current bag contains no large items
;;;			the current bag contains no medium items
;;;			the current bag contains < 18 small items
;;; delete 	the small item is to be bagged
;;; add		the small item is in the current bag
(defrule B11
(step bag-small-items)
?item-fact <- (item (name ?item-name) (size small))
;;;?current-bag-fact <- (current-bag (name ?bag-name) (item-size ?item-size&: (not ?item-size large)) (item-count ?item-count&:
?current-bag-fact <- (current-bag (name ?bag-name) (item-count ?item-count&:
(< ?item-count 18)))
=>
(retract ?item-fact)
(assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
(modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size small)))






;;; if 	step is bag-small-items
;;; 		a small item is to be bagged
;;; 		an empty bag is available
;;; delete 	the current bag is the current bag
;;; add		the empty bag is the current bag
(defrule B12
(step bag-small-items)
(item (name ?item-name) (size small))
?current-bag-fact <- (current-bag)
=>
(retract ?current-bag-fact)
(assert (current-bag)))





(defrule B13
?step-fact <- (step bag-small-items)
=>
(retract ?step-fact)
(assert (step done)))




(defrule log-bagged
(declare (salience 10))
(bagged (item-name ?item-name) (bag-name ?bag-name))
=>
(printout t ?item-name " in " ?bag-name crlf))
(defrule log-in-freezer-bag
(declare (salience 10))
(in-freezer-bag ?item-name)
=>
(printout t ?item-name " in freezer bag" crlf))